---
layout: single
title: "[실전코딩]소켓 통신 구조설계"
date: 2019-06-25 20:00:00 +0900
categories:
  - 실전코딩
tags:
  - nhn
comments: true
---

# 소켓 통신 구조 설계
http 프로토콜 위에서 놀다가 직접 소켓 통신 구현해야 할 일이 생겼다.
편하던 RestTemplate 이여 잠시 안녕... 

작은 부분을 맡아서 설계했지만 생각해 볼 사항들이 많아서 정리해두고자 한다.  
프로그램을 구현하면서 마주쳤던 요구사항과 어떤 식으로 풀어냈는지를 설명하는 글이 될 것 같다.

## 요구사항은 한마디로
- 금융 고객정보를 조회하는 API를 회사 내부에 제공

## 기술적 요구사항은 한마디로
- PG 회사와는 Socket 레벨로 통신하고, 회사 내부로 REST API 를 제공

금융 도메인에서는 아직 소켓 수준의 프로그래밍이 많은가보다. 
PG사 간의 통신에는 상호간의 일련의 규칙을 정해두고 규칙에 맞게 통신을 한다.  

무슨말이냐하니 Socket 통신시 byte[] 데이터를 보내는데,  
보내야할 데이터가 차지하는 byte[] 의 인덱스를 미리 지정한다.
고객명은 byte[0-12] 인덱스, 주소는 byte[13-33] 인덱스, ...  
보내야할 데이터가 더 짧을 경우 남는 인덱스는 빈칸으로 채우는 식이다.

이러한 방식에는 한가지 장점이 있다.
 1. 문자를 파싱하는데 컴퓨팅 리소스가 적게든다. 현재 많이 쓰는 JSON 방식과 비교해서 
 byte[] 범위지정 방식은 byte 레벨에서 부터 들어올 데이터를 알고 있으므로 파싱 부담이 덜하다.
 
 그리고 여러가지 단점들이 있다.
 1. 개발 리소스가 많이든다. http 프로토콜을 사용했을 때 사용할 수 있는 고수준의 라이브러리를 못쓰게 된다.
 1. 코드의 재사용이 어렵다. 상호간 통신 방식이 PG사 마다 다르기 때문에 특정 회사에 종속된 코드가 많아진다.
 1. 빡친다. 그냥 빡친다.
 
## 일련의 프로세스
1. 회사의 각 부서에서 빌링 REST API를 사용

1. 필터 층에서
   * 요청 민감정보 마스킹 로깅

1. 컨트롤러 층에서
   * 넘어온 데이터 유효성 체크
   * 클라이언트 요청 데이터 포멧을 서버 데이터 포멧으로 변경

1. 서비스 층에서 
   * PG 통신을 위한 데이터 세팅
   * 서버 데이터 포멧을 PG사 특화 데이터 포멧으로 변경
  
1. 공통 서비스층에서  
   (PG 통신을 공통 비즈니로직에서 처리한다)
   * 상호협약 데이터 세팅
   * byte[] 포맷으로 직렬화
   * 요청
   * 응답 데이터 역직렬화
   * 응답 데이터 유효성 체크
   * 예외 처리 (통신 예외 처리, 응답 에러코드 처리, 서버 예외 처리)
   * 통신 로그 민감정보 마스킹
  
1. 서비스 층에서
   * PG 통신 예외를 공통 예외로 변경
   * 예외 로깅 민감정보 암호화
  
1. 컨트롤러 층에서
   * 응답 API 포멧으로 정보 변환
   * 공통 예외 응답 API 포멧으로 변환

### 프로세스를 누군가 짜주지 않는다.
프로세스를 설계 할 때 중요하게 고려했던 것은 다음과 같다.
1. 어떻게 분리할 것인가. 어떤 로직이 어디에 위치해 있을 때 가장 효율적인가.
1. 프로세스 상 각각의 과정에서 적당한 데이터의 형태는 무엇인가.
1. 프로세스 상 각각의 과정에서 적당한 예외 형태는 무엇인가.

### 위 사항을 처리하면서 했던 생각들...
1. 어떻게 분리할 것인가.
   - 확장 포인트가 어디인가?  
     확장 포인트는 인터페이스 설계에서 중요한 요소이다. 당장 요구사항에 확장 포인트가 없다고 하더라도 이후 생겨날 확장 포인트를 생각해본다.
     서비스 층에서 현재 연결해야할 PG 사는 한 곳이지만 이후 동일한 요청을 처리하는 PG 사가 더 들어올 수 있다.
     서비스에서 PG 통신을 호출하는 부분을 인터페이스로 만들자.
   - 어디를 공통으로 묶어 주어야 하는가?  
     로직을 사용할 클라이언트가 다양하다면(API 제공, ADMIN 화면 등) 공통 부분을 빼내서 코드 중복을 피하자. 
     PG 통신을 공통 비즈니로직으로 뺀다.
   - 어디를 공통으로 묶어 주어야 하는가 2?  
     PG 사에 다양한 정보조회를 하는데 byte[]에 들어갈 데이터만 다르고 모든 과정이 똑같다.
     데이터를 byte[] 변환하는 과정을 제외하고, 인코딩, 암호화, 전송, 응답, 복호화, 디코딩을 공통으로 빼내자.
   - 어디에서 어떤 데이터를 세팅해야 하는가?  
     PG 통신 전문을 위한 데이터는 여러가지 성격으로 분리된다. 공통으로 쓰이는 데이터는 공통 부분에서 세팅해야지
     이후 확장 포인트를 늘릴 때 데이터 중복세팅 코드를 최소화 할 수 있다.
     * 고객에게 받아야 되는 데이터 : 정보 조회용 데이터
     * 서버에서 생성해야 되는 데이터 : 거래 시간
     * PG 사와 협의된 데이터 :  
       + 전문에 포함 : 요청 회사 코드
       + 전문을 구성 : 암호키
       + 전문 통신 : IP, PORT
     
1. 각각의 과정에서 적당한 데이터의 형태는 무엇인가.
   - 고객 친화적인 데이터?  
     API 설계할 때는 데이터명에 주의를 기울인다. 한번 제공된 API는 이후 수정이 불가한 경우가 많다. 직관적인 내이밍을 하자.  
     API 요청으로 받을 데이터 선별. 꼭 필요한 정보만 받고 불필요하게 데이터 개수를 늘리지 말자.
   - 서버 친화적인 데이터?  
     데이터 타입에 대한 고민이다. 오류를 최소화 하는 타입을 사용하자. Request로 넘어오는 데이터는 모두 String이다.
     때문에 잘못된 데이터가 넘어올 경우가 생긴다. 이를 파싱해서 숫자는 int, 분류는 enum 등의 값으로 세팅해주자.
   - PG 친화적인 데이터?  
     PG사 마다 전문을 구성할 요청, 응답 데이터가 다르다. 각각의 PG사가 사용하는 명칭을 고려해서 데이터 내이밍하자.
   - 또 다시 고객 친화적인 데이터?  
     PG 사가 다르더라도 고객이 사용할 API는 동일해야 한다.
   - 또 다시 서버 친화적인 데이터?  
     데이터 타입에 대한 고민이다. 직렬화 하기 편한 타입을 사용하자. PG통신 부분으로 들어오는 데이터는 그 전 단계에서
     잘 처리된 믿을 만한 데이터이다. 넘어온 데이터를 가지고 할 일은 오직 통신 하나 뿐이다. 통신 처리하기 편한 
     데이터 타입 String을 사용하자.
     
1. 각각의 과정에서 적당한 예외 형태는 무엇인가.
   - 고객 친화적인 예외?  
     * API 응답을 설계 할때는 응답포멧에 주의를 기울인다. 고객은 회사내부의 공통 API 포맷에 이미 익숙한 상태이다.
     공통 포맷을 따르자. 공통 에러코드를 따르자.  
     * 고객에게 어떤 메세지를 보낼 것인가? 본 API 서비스를 사용하는 고객은 회사 각 부서의 개발자다.
     에러 메세지가 너무 추상적으로 나와서 빡치지 않게 적절히 구체적으로 적어주자.
   - 서버 친화적인 예외?  
     * 서버에서 공통으로 사용하는 예외 포맷이 있다면 따르도록하자. 공통 예외는 공통 예외처리 로직이 있어서 통일성 있게 처리된다.
     따라서 관리 비용이 줄어든다.  
     * 로깅시 어떤 정보가 나와야 하는지 고려하자. 로깅 레벨에 따라서 보여줘야 할 정보를 다르게 가져가자. 로그를 너무
     많이 찍어서 IO 리소스를 과도하게 사용하지 않도록 한다.  
   - PG 친화적인 예외?  
     PG사 제공 API가 너무 불친절하다면 적절히 변환해주자. PG사가 에러코드만 제공하고 에러 메세지는 따로 보내지 않는다면
     에러 메세지를 적절히 매핑해서 예외로 던지자.
   - 또 다시 서버 친화적인 예외?  
     PG 마다 자신들의 에러코드를 가지고 있다. 각각에 대해 예외를 만들면 관리해야할 예외가 너무 많아진다. 공통 예외로 묶어보자.
   - 개발자 친화적인 예외?  
     * 로그 레벨을 적절하게 맞추자. 과도한 알림이 와서 정신적으로 피폐해지는 일이 없도록 하자.  
     본 서비스는 거래 로직이 아니라 단순한 정보 조회 로직이다. 공통 예외의 에러 레벨에서 매핑이 맞지 않다고 생각되면
     적절하게 로그레벨을 낮추자.
     * 특정 로그를 검색하는 일이 편하도록 메세지에 prefix를 달아보자. 예를 들어 "[정보조회]blabla ~" 이런식이다.
     로그를 찾는일을 결국 사람이 해야할 경우가 많으니 한눈에 들어오는 prefix를 다는게 좋다.
 
요구사항은 단순하게 정보조회 API 구현하라지만, 내부적으로 생각해야 할 요구사항이 점점 많아진다. 이제 시작이다.


## 구체적인 통신 로직 프로세스
1. 상호협약 데이터 세팅
1. 협의된 데이터 인코딩 적용
1. 협의된 데이터 byte[] 순서 적용
1. 협의된 데이터 암호화 적용
1. 협의된 포트로 데이터 전송
1. 응답 데이터 복호화
1. 응답 데이터 디코딩
1. 응답 데이터 파싱
1. 응답 데이터 유효성 체크
1. 예외 처리 (통신 예외 처리, 응답 에러코드 처리, 서버 예외 처리)
1. 통신 로그 민감정보 마스킹